# Copyright (c) 2024 - for information on the respective copyright owner
# see the NOTICE file

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Representation of ROS timers.
"""

from math import floor, gcd
from typing import List, Optional, Tuple

from as2fm.scxml_converter.ascxml_extensions.ros_entries import (
    RosField,
    RosTopicPublish,
    RosTopicPublisher,
)
from as2fm.scxml_converter.scxml_entries import (
    ScxmlAssign,
    ScxmlData,
    ScxmlDataModel,
    ScxmlExecutionBody,
    ScxmlIf,
    ScxmlRoot,
    ScxmlSend,
    ScxmlState,
    ScxmlTransition,
)

TIME_UNITS = {
    "s": 1,
    "ms": 1e-3,
    "us": 1e-6,
    "ns": 1e-9,
}

GLOBAL_TIMER_AUTOMATON = "autogenerated_global_timer"
GLOBAL_TIMER_TICK_ACTION = "global_timer_tick_action"
GLOBAL_TIMER_TICK_EVENT = "global_timer_tick_event"
ROS_TIMER_RATE_EVENT_PREFIX = "ros_time_rate."


def is_global_timer_event(event_name: str):
    """Check if the event name is the one stepping the global automaton forward."""
    return event_name == f"{GLOBAL_TIMER_TICK_EVENT}"


def convert_time_between_units(time: int, from_unit: str, to_unit: str) -> int:
    """Convert time from one unit to another."""
    assert from_unit in TIME_UNITS, f"Unit {from_unit} not supported."
    assert to_unit in TIME_UNITS, f"Unit {to_unit} not supported."
    assert time >= 0, "Time must be positive."
    if from_unit == to_unit:
        return time
    new_time = time * TIME_UNITS[from_unit] / TIME_UNITS[to_unit]
    # make sure we do not lose precision
    assert int(new_time) == new_time, f"Conversion from {from_unit} to {to_unit} is not exact."
    return int(new_time)


def _to_best_int_period(period: float) -> Tuple[int, str, float]:
    """Choose the best time unit for a given period.
    Such that the period is an integer and the unit is the largest possible."""
    for unit, factor in TIME_UNITS.items():
        period_in_unit = period / factor
        int_period_in_unit = floor(period_in_unit)
        if int_period_in_unit == period_in_unit:
            # This period exactly fits into the unit
            return int(period_in_unit), unit, factor
        elif int_period_in_unit > 100:
            # We do not want to have too large numbers
            return int_period_in_unit, unit, factor
    raise ValueError(f"Period {period} cannot be converted to an integer.")


class RosTimer(object):
    def __init__(self, name: str, freq: float) -> None:
        self.name = name
        self.freq = freq
        self.period = 1.0 / freq
        self.period_int, self.unit, self.factor = _to_best_int_period(self.period)


def get_gcd_of_timer_periods(timers: List[RosTimer]) -> Tuple[int, str]:
    """
    Get the greatest common divider of the time periods from the provided ROS timers.

    :param timers: The list of ROS timers.
    :return: The time step and time unit resulting from the GCD of the timers periods.
    """
    if len(timers) == 0:
        raise ValueError("At least one timer is required.")
    common_unit = "s"
    for timer in timers:
        if TIME_UNITS[timer.unit] < TIME_UNITS[common_unit]:
            common_unit = timer.unit
    timer_periods = [
        convert_time_between_units(timer.period_int, timer.unit, common_unit) for timer in timers
    ]
    common_period = gcd(*timer_periods)
    return common_period, common_unit


def make_global_timer_scxml(timers: List[RosTimer], max_time_ns: int) -> Optional[ScxmlRoot]:
    """
    Create a global timer SCXML automaton from a list of ROS timers.

    :param timers: The list of ROS timers.
    :return: The global timer SCXML.
    """
    if len(timers) == 0:
        return None
    global_timer_period, global_timer_period_unit = get_gcd_of_timer_periods(timers)
    timers_map = {
        timer.name: convert_time_between_units(
            timer.period_int, timer.unit, global_timer_period_unit
        )
        for timer in timers
    }
    try:
        max_time = convert_time_between_units(max_time_ns, "ns", global_timer_period_unit)
    except AssertionError:
        raise ValueError(
            f"Max time {max_time_ns}ns cannot be converted to '{global_timer_period_unit}'. "
            "The max_time must have a unit that is greater or equal to the smallest timer period."
        )
    curr_time_var = "current_time"
    scxml_root = ScxmlRoot(GLOBAL_TIMER_AUTOMATON)
    # Explicitly set that there are no custom types
    scxml_root.set_custom_data_types({})
    clock_topic_decl = RosTopicPublisher("clock", "builtin_interfaces/Time")
    scxml_root.add_ros_declaration(clock_topic_decl)
    scxml_root.set_data_model(ScxmlDataModel([ScxmlData(curr_time_var, "0", "int64")]))
    idle_state = ScxmlState("idle")
    # Tick timer with a delay of 1 (as there is no smaller time step needed in the model).
    # This way, the channel system own time-unit corresponds to a duration of
    # `global_timer_period` with unit `global_timer_period_unit`.
    # Timing is achieved by sending a delayed event to the timer itself.
    delay = ScxmlSend(
        event=GLOBAL_TIMER_TICK_EVENT,
        target_automaton=GLOBAL_TIMER_AUTOMATON,
        delay=1,
    )
    # send delayed 'tick_timer' event to self on entry of 'idle' state
    idle_state.set_on_entry([delay])
    global_timer_tick_body: ScxmlExecutionBody = [
        ScxmlAssign(curr_time_var, f"{curr_time_var} + {global_timer_period}"),
        _get_current_time_to_clock_msg_publish(
            clock_topic_decl, curr_time_var, global_timer_period_unit
        ),
    ]
    for timer_name, timer_period in timers_map.items():
        global_timer_tick_body.append(
            ScxmlIf(
                [
                    (
                        f"({curr_time_var} % {timer_period}) == 0",
                        [ScxmlSend(f"{ROS_TIMER_RATE_EVENT_PREFIX}{timer_name}")],
                    )
                ]
            )
        )
    # transition is activated by 'tick_timer' event sent on entry of 'idle' state
    timer_step_transition = ScxmlTransition.make_single_target_transition(
        "idle", [GLOBAL_TIMER_TICK_EVENT], f"{curr_time_var} < {max_time}", global_timer_tick_body
    )
    # This transition is selected if the condition from the one above fails to hold
    timer_out_transition = ScxmlTransition.make_single_target_transition(
        "timeout", [GLOBAL_TIMER_TICK_EVENT]
    )
    idle_state.add_transition(timer_step_transition)
    idle_state.add_transition(timer_out_transition)
    scxml_root.add_state(idle_state, initial=True)
    scxml_root.add_state(ScxmlState("timeout"))
    return scxml_root


def _get_current_time_to_clock_msg_publish(
    clock_decl: RosTopicPublisher, curr_time_var: str, time_unit: str
) -> RosTopicPublish:
    assert time_unit in TIME_UNITS
    if time_unit == "s":
        return RosTopicPublish(
            clock_decl, [RosField("sec", curr_time_var), RosField("nanosec", "0")]
        )
    n_units_per_sec = round(1.0 / TIME_UNITS[time_unit])
    time_unit_in_nsec = 1e9 / n_units_per_sec
    return RosTopicPublish(
        clock_decl,
        [
            RosField("sec", f"Math.floor({curr_time_var} / {n_units_per_sec})"),
            RosField("nanosec", f"({curr_time_var} % {n_units_per_sec}) * {time_unit_in_nsec}"),
        ],
    )
