# Copyright (c) 2024 - for information on the respective copyright owner
# see the NOTICE file

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Collection of SCXML utilities related to BT functionalities."""

import re
from enum import Enum, auto
from typing import Dict, Tuple, Type

from as2fm.scxml_converter.scxml_entries.utils import (
    PLAIN_SCXML_EVENT_DATA_PREFIX,
    SCXML_DATA_STR_TO_TYPE,
)

VALID_BT_INPUT_PORT_TYPES: Dict[str, Type] = SCXML_DATA_STR_TO_TYPE | {"string": str}
VALID_BT_OUTPUT_PORT_TYPES: Dict[str, Type] = SCXML_DATA_STR_TO_TYPE

# List of keys that are not going to be read as BT ports from the BT XML definition.
RESERVED_BT_PORT_NAMES = ["ID", "name"]

# Blackboard-related autogenerated events
BT_BLACKBOARD_REQUEST = "bt_blackboard_req"
BT_BLACKBOARD_GET = "bt_blackboard_get"

BT_SET_BLACKBOARD_PARAM = "value"
BT_BLACKBOARD_EVENT_VALUE = PLAIN_SCXML_EVENT_DATA_PREFIX + BT_SET_BLACKBOARD_PARAM


class BtResponse(Enum):
    """Enumeration of possible BT responses."""

    SUCCESS = auto()
    FAILURE = auto()
    RUNNING = auto()

    @staticmethod
    def str_to_int(resp_str: str) -> int:
        """Convert the BT response to an integer."""
        for response in BtResponse:
            if response.name == resp_str:
                return response.value
        raise ValueError(f"Error: {resp_str} is an invalid BT Status type.")

    @staticmethod
    def process_expr(expr: str) -> str:
        """Substitute occurrences of BT responses in the expression."""
        for response in BtResponse:
            expr = re.sub(rf"{response.name}", f"{response.value}", expr)
        return expr


def generate_bt_blackboard_set(bt_bb_ref_name: str) -> str:
    """
    Generate  the name of the evnt setting a specific Blackboard variable.

    :param bt_bb_ref_name: The name of the blackboard variable to set.
    :return: The name of the event to use to generate the specific variable.
    """
    return f"bt_blackboard_set_{bt_bb_ref_name}"


def generate_bt_tick_event(instance_id: str) -> str:
    """Generate the BT tick event name for a given BT node instance."""
    return f"bt_{instance_id}_tick"


def generate_bt_response_event(instance_id: str) -> str:
    """Generate the BT response event name for a given BT node instance."""
    return f"bt_{instance_id}_response"


def is_bt_event(event_name: str) -> bool:
    """Given an event name, returns whether it is related to a BT event or not."""
    bt_events = [f"bt_{suffix}" for suffix in ["tick", "running", "success", "failure"]]
    return event_name in bt_events


def replace_bt_event(event_name: str, instance_id: str) -> str:
    """Given a BT event name, returns the same event including the BT node instance."""
    assert is_bt_event(event_name), "Error: BT event instantiation: invalid BT event name."
    return f"bt_{instance_id}_{event_name.removeprefix('bt_')}"


def is_blackboard_reference(port_value: str) -> bool:
    """
    Check if a port value is a reference to a Blackboard variable.

    We consider a string to reference Blackboard variable if it is enclosed in curly braces.
    """
    return re.match(r"\{.+\}", port_value) is not None


def get_blackboard_variable_name(port_value: str) -> str:
    assert is_blackboard_reference(
        port_value
    ), f"Error: expected '{port_value}' to be a reference to a blackboard variable."
    return port_value.removeprefix("{").removesuffix("}")


def get_input_variable_as_scxml_expression(port_value: str) -> str:
    """
    Given an input variable it generates an expression as event data or single value.

    The outcome depends on whether port value refers to the BT blackboard or not.
    """
    if is_blackboard_reference(port_value):
        return PLAIN_SCXML_EVENT_DATA_PREFIX + get_blackboard_variable_name(port_value)
    return port_value


class BtPortsHandler:
    """Collector for declared BT ports and their assigned value."""

    @staticmethod
    def check_port_name_allowed(port_name: str) -> None:
        """Check if the port name is allowed."""
        # All port IDs are valid
        pass
        # assert (
        #     port_name not in RESERVED_BT_PORT_NAMES
        # ), f"Error: Port name {port_name} is reserved in BT"

    def __init__(self):
        # For each port name, store the port type string and value.
        self._in_ports: Dict[str, Tuple[str, str]] = {}
        self._out_ports: Dict[str, Tuple[str, str]] = {}

    def in_port_exists(self, port_name: str) -> bool:
        """Check if an input port exists."""
        return port_name in self._in_ports

    def out_port_exists(self, port_name: str) -> bool:
        """Check if an output port exists."""
        return port_name in self._out_ports

    def declare_in_port(self, port_name: str, port_type: str) -> None:
        """Add an input port to the handler."""
        BtPortsHandler.check_port_name_allowed(port_name)
        assert not self.in_port_exists(
            port_name
        ), f"Error: Input port {port_name} already declared as input port."
        assert not self.out_port_exists(
            port_name
        ), f"Error: Input port {port_name} already declared as output port."
        assert (
            port_type in VALID_BT_INPUT_PORT_TYPES
        ), f"Error: Unsupported input port type {port_type}."
        self._in_ports[port_name] = (port_type, None)

    def declare_out_port(self, port_name: str, port_type: str) -> None:
        """Add an output port to the handler."""
        BtPortsHandler.check_port_name_allowed(port_name)
        assert not self.out_port_exists(
            port_name
        ), f"Error: Output port {port_name} already declared as output port."
        assert not self.in_port_exists(
            port_name
        ), f"Error: Output port {port_name} already declared as input port."
        assert (
            port_type in VALID_BT_OUTPUT_PORT_TYPES
        ), f"Error: Unsupported output port type {port_type}."
        self._out_ports[port_name] = (port_type, None)

    def get_port_value(self, port_name: str) -> str:
        """Get the value of a port."""
        if self.in_port_exists(port_name):
            return self.get_in_port_value(port_name)
        elif self.out_port_exists(port_name):
            return self.get_out_port_value(port_name)
        else:
            raise RuntimeError(f"Error: Port {port_name} is not declared.")

    def get_all_ports(self) -> Dict[str, Tuple[str, str]]:
        """Get all declaed ports as a dict referencing port names to type and value."""
        return self._in_ports | self._out_ports

    def get_in_port_value(self, port_name: str) -> str:
        """Get the value of an input port."""
        assert self.in_port_exists(
            port_name
        ), f"Error: Port {port_name} is not declared as input port."
        port_value = self._in_ports[port_name][1]
        assert port_value is not None, f"Error: Port {port_name} has no assigned value."
        return port_value

    def get_out_port_value(self, port_name: str) -> str:
        """Get the value of an output port."""
        assert self.out_port_exists(
            port_name
        ), f"Error: Port {port_name} is not declared as input port."
        port_value = self._out_ports[port_name][1]
        assert port_value is not None, f"Error: Port {port_name} has no assigned value."
        assert is_blackboard_reference(
            port_value
        ), f"Error: Port {port_name} should be a blackboard reference, found value {port_value}"
        return port_value

    def set_port_value(self, port_name: str, port_value: str) -> None:
        """Set the value of a port."""
        if self.in_port_exists(port_name):
            self._set_in_port_value(port_name, port_value)
        elif self.out_port_exists(port_name):
            self._set_out_port_value(port_name, port_value)
        else:
            # The reserved port IDs can be set in the bt.xml even if they are unused in the plugin
            assert port_name in RESERVED_BT_PORT_NAMES, f"Error: Port {port_name} is not declared."

    def _set_in_port_value(self, port_name: str, port_value: str):
        """Set the value of an input port."""
        assert self.in_port_exists(
            port_name
        ), f"Error: Port {port_name} is not declared as input port."
        assert (
            self._in_ports[port_name][1] is None
        ), f"Error: Value of port {port_name} already assigned."
        port_type = self._in_ports[port_name][0]
        self._in_ports[port_name] = (port_type, port_value)

    def _set_out_port_value(self, port_name: str, port_value: str):
        """Set the value of an output port."""
        assert self.out_port_exists(
            port_name
        ), f"Error: Port {port_name} is not declared as output port."
        assert (
            self._out_ports[port_name][1] is None
        ), f"Error: Value of port {port_name} already assigned."
        assert is_blackboard_reference(
            port_value
        ), f"Error: value of output port {port_name} must be a blackboard variable."
        port_type = self._out_ports[port_name][0]
        self._out_ports[port_name] = (port_type, port_value)
