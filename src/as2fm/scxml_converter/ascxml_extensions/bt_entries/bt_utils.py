# Copyright (c) 2024 - for information on the respective copyright owner
# see the NOTICE file

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Collection of SCXML utilities related to BT functionalities."""

import re
from enum import Enum, auto
from typing import Dict, Optional, Type, Union

from as2fm.scxml_converter.data_types.type_utils import SCXML_DATA_STR_TO_TYPE
from as2fm.scxml_converter.scxml_entries import ScxmlBase
from as2fm.scxml_converter.scxml_entries.utils import (
    PLAIN_SCXML_EVENT_DATA_PREFIX,
    to_integer,
)

VALID_BT_INPUT_PORT_TYPES: Dict[str, Type] = SCXML_DATA_STR_TO_TYPE
VALID_BT_OUTPUT_PORT_TYPES: Dict[str, Type] = SCXML_DATA_STR_TO_TYPE

BT_N_CHILDREN_PORT = "CHILDREN_COUNT"

# List of keys that are not going to be read as BT ports from the BT XML definition.
RESERVED_BT_PORT_NAMES = ["ID", "name", BT_N_CHILDREN_PORT]

# Blackboard-related autogenerated events
BT_BLACKBOARD_REQUEST = "bt_blackboard_req"
BT_BLACKBOARD_GET = "bt_blackboard_get"

BT_SET_BLACKBOARD_PARAM = "value"
BT_BLACKBOARD_EVENT_VALUE = PLAIN_SCXML_EVENT_DATA_PREFIX + BT_SET_BLACKBOARD_PARAM


class BtResponse(Enum):
    """Enumeration of possible BT responses."""

    SUCCESS = auto()
    FAILURE = auto()
    RUNNING = auto()

    @staticmethod
    def str_to_int(resp_str: str) -> Optional[int]:
        """Convert the BT response to an integer."""
        for response in BtResponse:
            if response.name == resp_str:
                return response.value
        return None

    @staticmethod
    def process_expr(expr: str) -> str:
        """Substitute occurrences of BT responses in the expression."""
        for response in BtResponse:
            expr = re.sub(rf"{response.name}", f"{response.value}", expr)
        return expr


def process_bt_child_seq_id(
    scxml_type: Type[ScxmlBase], child_seq_id: Union[str, int]
) -> Union[str, int]:
    """
    Convert the child sequence ID to int or string depending on the content.
    """
    if isinstance(child_seq_id, int):
        return child_seq_id
    elif isinstance(child_seq_id, str):
        child_seq_id = child_seq_id.strip()
        int_seq_id = to_integer(scxml_type, "id", child_seq_id)
        if int_seq_id is not None:
            return int_seq_id
        assert (
            child_seq_id.isidentifier()
        ), f"Error: {scxml_type.get_tag_name()}: invalid child seq id name '{child_seq_id}'."
        return child_seq_id
    raise TypeError(
        f"Error: {scxml_type.get_tag_name()}: invalid child seq id type '{type(child_seq_id)}'."
    )


def generate_bt_blackboard_set(bt_bb_ref_name: str) -> str:
    """
    Generate  the name of the evnt setting a specific Blackboard variable.

    :param bt_bb_ref_name: The name of the blackboard variable to set.
    :return: The name of the event to use to generate the specific variable.
    """
    bb_var = bt_bb_ref_name.strip().rstrip()
    assert len(bb_var) > 0, "Empty blackboard variable provided."
    assert bb_var.count("{") + bb_var.count("}") == 0, "Invalid Blackboard variable name."
    return f"bt_blackboard_set_{bb_var}"


def generate_bt_tick_event(instance_id: int) -> str:
    """Generate the BT tick event name for a given BT node instance."""
    assert isinstance(instance_id, int)
    return f"bt_{instance_id}_tick"


def is_bt_tick_event(event_name: str) -> bool:
    """Check is the event is used for ticking a BT node."""
    return re.match(r"^bt_[0-9]+_tick$", event_name) is not None


def generate_bt_halt_event(instance_id: int) -> str:
    """Generate the BT halt event name for a given BT node instance."""
    assert isinstance(instance_id, int)
    return f"bt_{instance_id}_halt"


def is_bt_halt_event(event_name: str) -> bool:
    """Check if the event is used for halting a BT node."""
    return re.match(r"^bt_[0-9]+_halt$", event_name) is not None


def generate_bt_tick_response_event(instance_id: int) -> str:
    """Generate the BT response event name for a given BT node instance."""
    assert isinstance(instance_id, int)
    return f"bt_{instance_id}_response"


def is_bt_tick_response_event(event_name: str) -> bool:
    """Check if the event name is for BT node's responses(success, failure, running)."""
    return re.match(r"^bt_[0-9]+_response$", event_name) is not None


def generate_bt_halt_response_event(instance_id: int) -> str:
    """Generate the BT response event name for a given BT node instance."""
    assert isinstance(instance_id, int)
    return f"bt_{instance_id}_halt_response"


def is_bt_halt_response_event(event_name: str) -> bool:
    """Check if the event name is for a BT node's halt response."""
    return re.match(r"^bt_[0-9]+_halt_response$", event_name) is not None


def is_removed_bt_event(event_name: str) -> bool:
    """Given an event name, returns whether it is related to a BT event or not."""
    bt_events = [f"bt_{suffix}" for suffix in ["tick", "running", "success", "failure"]]
    return event_name in bt_events


def is_blackboard_reference(port_value: str) -> bool:
    """
    Check if a port value is a reference to a Blackboard variable.

    We consider a string to reference Blackboard variable if it is enclosed in curly braces.
    """
    return re.match(r"\{.+\}", port_value) is not None


def get_blackboard_variable_name(port_value: str) -> str:
    assert is_blackboard_reference(
        port_value
    ), f"Error: expected '{port_value}' to be a reference to a blackboard variable."
    return port_value.removeprefix("{").removesuffix("}")


def get_input_variable_as_scxml_expression(port_value: str) -> str:
    """
    Given an input variable it generates an expression as event data or single value.

    The outcome depends on whether port value refers to the BT blackboard or not.
    """
    if is_blackboard_reference(port_value):
        return PLAIN_SCXML_EVENT_DATA_PREFIX + get_blackboard_variable_name(port_value)
    return port_value
