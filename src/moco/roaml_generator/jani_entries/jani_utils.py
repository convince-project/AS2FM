# Copyright (c) 2024 - for information on the respective copyright owner
# see the NOTICE file

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Collection of various utilities for Jani entries."""

from typing import List, MutableSequence, Optional, Tuple, Type, Union

from moco.moco_common.array_type import ArrayInfo, get_default_expression_for_type, is_array_type
from moco.moco_common.common import ValidJaniTypes
from moco.roaml_generator.jani_entries import JaniExpression, JaniExpressionType, JaniVariable
from moco.roaml_generator.jani_entries.jani_expression_generator import array_create_operator


def is_expression_array(expr: JaniExpression) -> bool:
    """Determine is an expression is an array operator ('av' or 'ac')."""
    exp_operator, _ = expr.as_operator()
    return exp_operator is not None and exp_operator in ("ac", "av")


def is_expression_variable_or_array_access(expr: JaniExpression) -> bool:
    """Determine whether an expression refers to a variable (with or without array access)."""
    assert isinstance(expr, JaniExpression), f"Unexpected input type '{type(expr)}'."
    expr_type = expr.get_expression_type()
    if expr_type == JaniExpressionType.IDENTIFIER:
        assert expr.as_identifier() is not None, "Cannot extract identifier from input expression."
        return True
    if expr_type == JaniExpressionType.OPERATOR:
        expr_operator, _ = expr.as_operator()
        assert expr_operator is not None, "Cannot extract operator from input expression."
        return expr_operator == "aa"
    return False


def get_array_access_name_and_indexes(expr: JaniExpression) -> Tuple[str, List[int]]:
    """
    Extract the identifier name and the list of access indexes from an aa expression.

    :param expr: The array access Jani expression.
    :return: A tuple with the name of the array var. and the accessed indexes.
    """
    expr_operator, expr_operand = expr.as_operator()
    assert expr_operator == "aa", f"Unexpected array operator: '{expr_operator}' != 'aa'."
    assert isinstance(expr_operand, dict)
    aa_exp = expr_operand["exp"]
    assert isinstance(aa_exp, JaniExpression)
    aa_idx_expr = expr_operand["index"]
    assert isinstance(aa_idx_expr, JaniExpression)
    aa_index_jani_val = aa_idx_expr.as_literal()
    assert aa_index_jani_val is not None
    aa_index_value = aa_index_jani_val.value()
    assert isinstance(aa_index_value, int)
    if aa_exp.get_expression_type() == JaniExpressionType.IDENTIFIER:
        array_var_name = aa_exp.as_identifier()
        assert array_var_name is not None
        return array_var_name, [aa_index_value]
    # else
    array_var_name, nested_idxs = get_array_access_name_and_indexes(aa_exp)
    return array_var_name, nested_idxs + [aa_index_value]


def is_variable_array(variable: JaniVariable) -> bool:
    """
    Check if a variable is an array.

    :param variable: The instance of the variable to check.
    :return: True if the variable is an array, False otherwise.
    """
    return is_array_type(variable.get_type())


def get_expression_array_length(expr: JaniExpression) -> int:
    """Get the length of the array generated by the provided expression."""
    assert is_expression_array(expr), f"The input expression {expr} is not an array ('ac', 'av')."
    operator, operands = expr.as_operator()
    if operator == "ac":
        return operands["length"].as_literal().value()
    return len(operands["elements"].as_literal().value())


def generate_jani_variable(
    var_name: str, var_type: Type[ValidJaniTypes], array_info: Optional[ArrayInfo] = None
) -> Union[JaniExpression, JaniVariable]:
    """Helper to make a JaniVariable object."""
    if is_array_type(var_type):
        assert array_info is not None, f"No array info  provided for array variable {var_name}."
        init_value = array_create_operator(array_info)
        var_type = MutableSequence
    else:
        init_value = JaniExpression(get_default_expression_for_type(var_type))
    return JaniVariable(var_name, var_type, init_value, False, array_info)
