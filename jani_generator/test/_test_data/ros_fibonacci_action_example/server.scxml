<?xml version="1.0" encoding="UTF-8"?>
<scxml 
    initial="idle" 
    version="1.0" 
    name="server"
    model_src=""
    xmlns="http://www.w3.org/2005/07/scxml">

    <datamodel>
        <!-- Goal fields -->
        <data id="order" type="int32" expr="0" />
        <!-- ID of the goal_id to cancel -->
        <data id="cancel_id" type="int32" expr="0" />
        <!-- ID of the last thread that terminated -->
        <data id="finished_thread_id" type="int32" expr="0" />
        <!-- ID of the next goal to be sent -->
        <data id="next_goal_id" type="int32" expr="0" />
        <!-- TODO: Use array -->
        <!-- Keep track of which thread is in use -->
        <data id="thread_1_busy" type="bool" expr="False" />
        <data id="thread_2_busy" type="bool" expr="False" />
        <data id="thread_to_start" type="int32" expr="0" />
    </datamodel>

    <ros_action_server action_name="/fibonacci" type="example_interfaces/Fibonacci" />

    <state id="idle">
        <ros_action_handle_goal action_name="/fibonacci" target="check_goal">
            <assign location="order" expr="_req.order" />
        </ros_action_handle_goal>
        <ros_action_handle_cancel action_name="/fibonacci" target="cancel_goal">
            <!-- TODO: This could be autogenerated from the tag... -->
            <assign location="cancel_id" expr="_event.goal_id" />
        </ros_action_handle_cancel>
        <transition event="terminated_fibonacci" target="reset_thread">
            <assign location="finished_thread_id" expr="_event.thread_id" />
        </transition>
    </state>

    <state id="check_goal">
        <onentry>
            <if cond="thread_1_busy == False">
                <assign location="thread_1_busy" expr="True" />
                <assign location="thread_to_start" expr="1" />
            <elseif cond="thread_2_busy == False" />
                <assign location="thread_2_busy" expr="True" />
                <assign location="thread_to_start" expr="2" />
            <else />
                <assign location="thread_to_start" expr="-1" />
            </if>
        </onentry>
        <transition target="idle" cond="thread_to_start > 0">
            <!-- Basically sending an event... -->
            <assign location="next_goal_id" expr="next_goal_id + 1" />
            <ros_action_accept_goal action_name="/fibonacci" goal_id="next_goal_id" />
            <!-- This send event could be wrapped in another method. Kept separated from 
             ros_action_accept_goal for flexibility. -->
            <!-- This should be expanded into multiple send events, one for each possible thread -->
            <ros_action_start_thread action_name="/fibonacci" thread_id="thread_to_start">
                <param name="goal_id" expr="next_goal_id" />
                <param name="order" expr="order" />
            </ros_action_start_thread>
        </transition>
        <!-- In case the prev. transition condition is not holding, reject! -->
        <transition target="idle">
            <ros_action_reject_goal action_name="/fibonacci" />
        </transition>
    </state>

    <state id="cancel_goal">
        <onentry>
            <if cond="cancel_id == 1">
                <assign location="thread_1_busy" expr="False" />
            <elseif cond="cancel_id == 2" />
                <assign location="thread_2_busy" expr="False" />
            </if>
        </onentry>
        <transition target="idle">
            <ros_action_cancel_goal action_name="/fibonacci" goal_id="cancel_id"/>
        </transition>
    </state>

    <state id="reset_thread">
        <onentry>
            <if cond="finished_thread_id == 1">
                <assign location="thread_1_busy" expr="False" />
            <elseif cond="finished_thread_id == 2" />
                <assign location="thread_2_busy" expr="False" />
            </if>
        </onentry>
        <transition target="idle" />
    </state>

</scxml>
