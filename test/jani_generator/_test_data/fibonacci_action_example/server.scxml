<?xml version="1.0" encoding="UTF-8"?>
<scxml
    initial="idle"
    version="1.0"
    name="server"
    model_src=""
    xmlns="http://www.w3.org/2005/07/scxml">

    <ros_action_server name="act_srv" action_name="/fibonacci" type="example_interfaces/Fibonacci" />

    <!--
    The action thread is a self-contained scxml entry, that will be translated to n. FSMs, depending on n_threads.
     -->
    <ros_action_thread name="act_srv" n_threads="2" initial="idle">
        <datamodel>
            <!-- ID of the thread instance -->
            <!-- Goal fields -->
            <data id="goal_id" type="int32" expr="-1" />
            <data id="order" type="int32" expr="0" />
            <!-- Exec fields -->
            <data id="sequence" type="int32[]" expr="[]" />
        </datamodel>

        <state id="idle">
            <onentry>
                <assign location="sequence.length" expr="0" />
                <assign location="goal_id" expr="-1" />
                <!-- Signal meant to tell the server the thread is now available -->
                <ros_action_thread_free name="act_srv" />
            </onentry>
            <!-- This will check if the thread_id matches with the request -->
            <ros_action_handle_thread_start name="act_srv" target="execute">
                <assign location="goal_id" expr="_action.goal_id" />
                <assign location="order" expr="_goal.order" />
            </ros_action_handle_thread_start>
        </state>

        <state id="execute">
            <onentry>
                <if cond="sequence.length == 0">
                    <assign location="sequence[0]" expr="0" />
                <elseif cond="sequence.length == 1" />
                    <assign location="sequence[1]" expr="1" />
                <else />
                    <assign location="sequence[sequence.length]" expr="sequence[sequence.length - 1] + sequence[sequence.length - 2]" />
                </if>
            </onentry>
            <!-- Comment out action canceling, not implemented yet -->
            <!-- The condition on the goal ID could be autogenerated from the tag, but keep explicit for now -->
            <!-- <ros_action_handle_cancel name="act_srv" target="idle" cond="_event.data.goal_id == goal_id" /> -->
            <transition cond="sequence.length == order + 1" target="idle">
                <!-- Results and feedback ROS tags need to add the thread_id to the fields, too. -->
                <ros_action_succeed name="act_srv" goal_id="goal_id">
                    <field name="sequence" expr="sequence" />
                </ros_action_succeed>
            </transition>
            <transition target="execute">
                <ros_action_feedback name="act_srv" goal_id="goal_id">
                    <field name="sequence" expr="sequence" />
                </ros_action_feedback>
            </transition>
        </state>
    </ros_action_thread>

    <datamodel>
        <!-- Goal fields -->
        <data id="goal_id" type="int32" expr="0" />
        <data id="order" type="int32" expr="0" />
        <!-- Keep track of which thread is in use -->
        <!-- TODO: Use array -->
        <data id="thread_0_busy" type="bool" expr="true" />
        <data id="thread_1_busy" type="bool" expr="true" />
        <data id="thread_to_start" type="int32" expr="-1" />
        <data id="free_thread_id" type="int32" expr="-1" />
    </datamodel>

    <state id="idle">
        <onentry>
            <assign location="thread_to_start" expr="-1" />
        </onentry>
        <ros_action_handle_goal name="act_srv" target="check_goal">
            <assign location="goal_id" expr="_action.goal_id" />
            <assign location="order" expr="_goal.order" />
        </ros_action_handle_goal>
        <ros_action_handle_thread_free name="act_srv" target="idle">
            <!-- Store a local copy of the received ID, to prevent it being changed while evaluating the if -->
            <!-- TODO:
            It might make sense to enforce the pattern of assigning event variables to local variables and
            evaluate them afterwards, preventing event variables from being used after the initial assignment block.
            This could solve problems with the event variables being changed by other actions in the meantime and
            evaluating the type of event variables at conversion time.
            -->
            <assign location="free_thread_id" expr="_event.data.thread_id" />
            <if cond="free_thread_id == 0">
                <assign location="thread_0_busy" expr="false" />
            <elseif cond="free_thread_id == 1" />
                <assign location="thread_1_busy" expr="false" />
            </if>
        </ros_action_handle_thread_free>
    </state>

    <state id="check_goal">
        <onentry>
            <if cond="thread_0_busy == false">
                <assign location="thread_0_busy" expr="true" />
                <assign location="thread_to_start" expr="0" />
            <elseif cond="thread_1_busy == false" />
                <assign location="thread_1_busy" expr="true" />
                <assign location="thread_to_start" expr="1" />
            <else />
                <assign location="thread_to_start" expr="-1" />
            </if>
        </onentry>
        <transition target="idle">
            <if cond="thread_to_start >= 0">
                <!-- Basically sending an event... -->
                <ros_action_accept_goal name="act_srv" goal_id="goal_id"/>
                <!-- The thread ID is appended as an additional param in the send event.
                It will be handled on the thread side -->
                <ros_action_start_thread name="act_srv" thread_id="thread_to_start" goal_id="goal_id">
                    <field name="order" expr="order" />
                </ros_action_start_thread>
            <else />
                <ros_action_reject_goal name="act_srv" goal_id="goal_id"/>
            </if>
        </transition>
    </state>

</scxml>
