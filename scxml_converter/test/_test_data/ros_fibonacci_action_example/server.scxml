<?xml version="1.0" encoding="UTF-8"?>
<scxml 
    initial="idle" 
    version="1.0" 
    name="server"
    model_src=""
    xmlns="http://www.w3.org/2005/07/scxml">

    <ros_action_server name="act_srv" action_name="/fibonacci" type="example_interfaces/Fibonacci" />

    <!--
    The action thread is a self-contained scxml entry, that will be translated to n. FSMs, depending on n_threads.
     -->
    <ros_action_thread name="act_srv" n_threads="2" initial="idle">
        <datamodel>
            <!-- ID of the thread instance -->
            <!-- Goal fields -->
            <data id="goal_id" type="int32" expr="0" />
            <data id="order" type="int32" expr="0" />
            <!-- Exec fields -->
            <data id="sequence" type="int32[]" expr="Array(50)" />
            <data id="sequence__len" type="int32" expr="0" />
        </datamodel>

        <state id="idle">
            <onentry>
                <assign location="sequence__len" expr="0" />
                <assign location="goal_id" expr="0" />
                <!-- Signal meant to tell the server the thread is now available -->
                <ros_action_thread_free name="act_srv" />
            </onentry>
            <!-- This will check if the thread_id matches with the request -->
            <ros_action_handle_thread_start name="act_srv" target="execute">
                <assign location="order" expr="_req.order" />
            </ros_action_handle_thread_start>
        </state>

        <state id="execute">
            <onentry>
                <if cond="sequence__len == 0">
                    <assign location="sequence[0]" expr="0" />
                <elseif cond="sequence__len == 1" />
                    <assign location="sequence[1]" expr="1" />
                <else />
                    <assign location="sequence[sequence__len]" expr="sequence[sequence__len - 1] + sequence[sequence__len - 2]" />
                </if>
                <assign location="sequence__len" expr="sequence__len + 1" />
            </onentry>
            <!-- The condition on the goal ID could be autogenerated from the tag, but keep explicit for now -->
            <ros_action_handle_cancel name="act_srv" target="idle" cond="_event.goal_id == goal_id" />
            <transition cond="sequence__len == order + 1" target="idle">
                <!-- Results and feedback ROS tags need to add the thread_id to the fields, too. -->
                <ros_action_succeed name="act_srv">
                    <field name="sequence" expr="sequence" />
                    <field name="sequence__len" expr="sequence__len" />
                </ros_action_succeed>
            </transition>
            <transition target="execute">
                <ros_action_feedback name="act_srv">
                    <field name="sequence" expr="sequence" />
                    <field name="sequence__len" expr="sequence__len" />
                </ros_action_feedback>
            </transition>
        </state>
    </ros_action_thread>

    <datamodel>
        <!-- Goal fields -->
        <data id="order" type="int32" expr="0" />
        <!-- ID of the goal_id to cancel -->
        <data id="cancel_id" type="int32" expr="0" />
        <!-- ID of the last thread that terminated -->
        <data id="finished_thread_id" type="int32" expr="0" />
        <!-- ID of the next goal to be sent -->
        <data id="next_goal_id" type="int32" expr="0" />
        <!-- TODO: Use array -->
        <!-- Keep track of which thread is in use -->
        <data id="thread_1_busy" type="bool" expr="False" />
        <data id="thread_2_busy" type="bool" expr="False" />
        <data id="thread_to_start" type="int32" expr="0" />
    </datamodel>

    <state id="idle">
        <ros_action_handle_goal name="act_srv" target="check_goal">
            <assign location="next_goal_id" expr="_req.goal_id" />
            <assign location="order" expr="_req.order" />
        </ros_action_handle_goal>
        <ros_action_handle_thread_free name="act_srv" target="idle">
            <if cond="_event.thread_id == 0">
                <assign location="thread_0_busy" expr="False" />
            <elseif cond="_event.thread_id == 1" />
                <assign location="thread_1_busy" expr="False" />
            </if>
        </ros_action_handle_thread_free>
    </state>

    <state id="check_goal">
        <onentry>
            <if cond="thread_1_busy == False">
                <assign location="thread_1_busy" expr="True" />
                <assign location="thread_to_start" expr="1" />
            <elseif cond="thread_2_busy == False" />
                <assign location="thread_2_busy" expr="True" />
                <assign location="thread_to_start" expr="2" />
            <else />
                <assign location="thread_to_start" expr="-1" />
            </if>
        </onentry>
        <transition target="idle" cond="thread_to_start > 0">
            <!-- Basically sending an event... -->
            <ros_action_accept_goal name="act_srv">
                <field name="goal_id" expr="next_goal_id" />
            <ros_action_accept_goal />
            <!-- This send event could be wrapped in another method. Kept separated from 
             ros_action_accept_goal for flexibility. -->
            <!-- This should be expanded into multiple send events, one for each possible thread -->
            <ros_action_start_thread name="act_srv" thread_id="thread_to_start">
                <param name="goal_id" expr="next_goal_id" />
                <param name="order" expr="order" />
            </ros_action_start_thread>
        </transition>
        <!-- In case the prev. transition condition is not holding, reject! -->
        <transition target="idle">
            <ros_action_reject_goal name="act_srv">
                <field name="goal_id" expr="next_goal_id" />
            </ros_action_reject_goal>
        </transition>
    </state>

    <state id="cancel_goal">
        <onentry>
            <if cond="cancel_id == 1">
                <ros_action_cancel_thread name="act_srv" thread_id="0" />
                <assign location="thread_1_busy" expr="False" />
            <elseif cond="cancel_id == 2" />
                <ros_action_cancel_thread name="act_srv" thread_id="1" />
                <assign location="thread_2_busy" expr="False" />
            </if>
        </onentry>
        <transition target="idle">
            <ros_action_cancel_goal name="act_srv" goal_id="cancel_id"/>
        </transition>
    </state>

    <state id="reset_thread">
        <onentry>
            <if cond="finished_thread_id == 1">
                <assign location="thread_1_busy" expr="False" />
            <elseif cond="finished_thread_id == 2" />
                <assign location="thread_2_busy" expr="False" />
            </if>
        </onentry>
        <transition target="idle" />
    </state>

</scxml>
